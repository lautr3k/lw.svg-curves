{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///lw.svg-curves.js","webpack:///webpack/bootstrap aded64610fa5676dd311","webpack:///./curves.js","webpack:///../~/lw.svg-path/dist/lw.svg-path.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","TypeError","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_classCallCheck","instance","Constructor","mod","x","clamp","val","min","max","Math","distance","p0","p1","sqrt","pow","y","angle","v0","v1","n","acos","defineProperty","QuadricBezier","CubicBezier","Arc","undefined","_get","get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","getter","_createClass","defineProperties","target","props","i","length","descriptor","key","protoProps","staticProps","_lw","MATH_PI_2","PI","DEG_TO_RAD","TraceBase","settings","path","linear","step","resolution","segmentLength","assign","arcLength","arcLengthMap","t","Point","point","push","prevPoint","getPointAtT","nextPoint","u","targetDistanceFromStartingPoint","resultantT","prevArcLength","prevT","every","entry","endDiff","startDiff","linearFactor","getPoint","_approximateLength","segments","round","_clearPath","_addPoint","_postTrace","getPath","_TraceBase","apply","arguments","radians","p2","rx","abs","ry","__addPoint","dx","dy","transformedPoint","cos","sin","radiiCheck","cSquareNumerator","cSquareRootDenom","cRadicand","cCoef","large","sweep","transformedCenter","center","startVector","endVector","startAngle","sweepAngle","init","_TraceBase2","p3","p4","_B1","_B2","_B3","_B4","_C1","unshift","_TraceBase3","e","o","parseFloat","isNaN","console","error","Error","r","points","forEach","X","parseInt","Y","addPoint","isEqual","isClosed","map","Path","default"],"mappings":"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","file":"lw.svg-curves.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SVGCurves\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SVGCurves\"] = factory();\n\telse\n\t\troot[\"SVGCurves\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SVGCurves\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SVGCurves\"] = factory();\n\telse\n\t\troot[\"SVGCurves\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.QuadricBezier = exports.CubicBezier = exports.Arc = undefined;\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Base code from : https://github.com/MadLittleMods/svg-curve-lib/blob/master/src/js/svg-curve-lib.js\n\t\n\t\n\tvar _lw = __webpack_require__(2);\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar MATH_PI_2 = Math.PI * 2;\n\tvar DEG_TO_RAD = Math.PI / 180;\n\t\n\tfunction mod(x, m) {\n\t    return (x % m + m) % m;\n\t}\n\t\n\tfunction clamp(val, min, max) {\n\t    return Math.min(Math.max(val, min), max);\n\t}\n\t\n\tfunction distance(p0, p1) {\n\t    return Math.sqrt(Math.pow(p1.x - p0.x, 2) + Math.pow(p1.y - p0.y, 2));\n\t}\n\t\n\tfunction angle(v0, v1) {\n\t    var p = v0.x * v1.x + v0.y * v1.y;\n\t    var n = Math.sqrt((Math.pow(v0.x, 2) + Math.pow(v0.y, 2)) * (Math.pow(v1.x, 2) + Math.pow(v1.y, 2)));\n\t    return (v0.x * v1.y - v0.y * v1.x < 0 ? -1 : 1) * Math.acos(p / n);\n\t}\n\t\n\t// Abstract class\n\t\n\tvar TraceBase = function () {\n\t    function TraceBase(settings) {\n\t        _classCallCheck(this, TraceBase);\n\t\n\t        // Set defaults properties\n\t        this.path = []; // Points collection [x,y, x,y, ...]\n\t        this.linear = true; // Linear trace mode\n\t        this.step = 0.01; // Step resolution if linear mode = false\n\t        this.resolution = 500; // Number of segments we use to approximate arc length\n\t        this.segmentLength = 0.1; // Segment length\n\t\n\t        // Update properties from user settings\n\t        Object.assign(this, settings || {});\n\t\n\t        // Arc length properties\n\t        this.arcLength = null;\n\t        this.arcLengthMap = null;\n\t    }\n\t\n\t    _createClass(TraceBase, [{\n\t        key: '_clearPath',\n\t        value: function _clearPath() {\n\t            this.path = [];\n\t        }\n\t    }, {\n\t        key: 'getPath',\n\t        value: function getPath() {\n\t            return this.path;\n\t        }\n\t    }, {\n\t        key: 'getPointAtT',\n\t        value: function getPointAtT(t) {\n\t            return new _lw.Point(0, 0);\n\t        }\n\t    }, {\n\t        key: '_addPoint',\n\t        value: function _addPoint(point) {\n\t            this.path.push(point.x, point.y);\n\t        }\n\t    }, {\n\t        key: '_postTrace',\n\t        value: function _postTrace() {\n\t            // Do additional tasks\n\t        }\n\t    }, {\n\t        key: '_approximateLength',\n\t        value: function _approximateLength() {\n\t            var arcLength = 0;\n\t            var arcLengthMap = [];\n\t            var prevPoint = this.getPointAtT(0);\n\t\n\t            var i = void 0,\n\t                t = void 0,\n\t                nextPoint = void 0;\n\t\n\t            for (i = 0; i < this.resolution; i++) {\n\t                t = clamp(i * (1 / this.resolution), 0, 1);\n\t                nextPoint = this.getPointAtT(t);\n\t                arcLength += distance(prevPoint, nextPoint);\n\t\n\t                arcLengthMap.push({ t: t, arcLength: arcLength });\n\t\n\t                prevPoint = nextPoint;\n\t            }\n\t\n\t            // Last stretch to the endpoint\n\t            nextPoint = this.getPointAtT(1);\n\t            arcLength += distance(prevPoint, nextPoint);\n\t\n\t            arcLengthMap.push({ t: 1, arcLength: arcLength });\n\t            Object.assign(this, { arcLength: arcLength, arcLengthMap: arcLengthMap });\n\t        }\n\t    }, {\n\t        key: 'getPointAtU',\n\t        value: function getPointAtU(u) {\n\t            u = clamp(u, 0, 1);\n\t\n\t            var targetDistanceFromStartingPoint = u * this.arcLength;\n\t\n\t            var resultantT = 0;\n\t            var prevArcLength = 0;\n\t            var prevT = 0;\n\t\n\t            this.arcLengthMap.every(function (entry) {\n\t                var t = entry.t;\n\t                var arcLength = entry.arcLength;\n\t\n\t                // Once we go a past our target\n\t                // Lets interpolate from a previous to current\n\t                if (arcLength >= targetDistanceFromStartingPoint) {\n\t                    var endDiff = arcLength - targetDistanceFromStartingPoint;\n\t                    var startDiff = targetDistanceFromStartingPoint - prevArcLength;\n\t                    var linearFactor = startDiff / (endDiff + startDiff) || 0;\n\t\n\t                    resultantT = prevT + (t - prevT) * linearFactor;\n\t\n\t                    // Break\n\t                    return false;\n\t                }\n\t\n\t                prevArcLength = arcLength;\n\t                prevT = t;\n\t\n\t                return true;\n\t            });\n\t\n\t            return this.getPointAtT(resultantT);\n\t        }\n\t    }, {\n\t        key: 'trace',\n\t        value: function trace(settings) {\n\t            // Update properties from user settings\n\t            Object.assign(this, settings || {});\n\t\n\t            // Default getPoint settings\n\t            var getPoint = 'getPointAtT';\n\t            var step = this.step;\n\t\n\t            // Linear mode ?\n\t            if (this.linear) {\n\t                this._approximateLength();\n\t\n\t                var segments = Math.round(this.arcLength / this.segmentLength);\n\t\n\t                getPoint = 'getPointAtU';\n\t                step = 1 / segments;\n\t            }\n\t\n\t            // Clear points list\n\t            this._clearPath();\n\t\n\t            // Trace the path\n\t            for (var t = 0; t <= 1; t += step) {\n\t                this._addPoint(this[getPoint](t));\n\t            }\n\t\n\t            // Do additional tasks\n\t            this._postTrace();\n\t\n\t            // Return the path\n\t            return this.getPath();\n\t        }\n\t    }]);\n\t\n\t    return TraceBase;\n\t}();\n\t\n\t// Rewrite from https://github.com/MadLittleMods/svg-curve-lib/blob/master/src/js/svg-curve-lib.js#L84\n\t\n\t\n\tvar Arc = function (_TraceBase) {\n\t    _inherits(Arc, _TraceBase);\n\t\n\t    function Arc() {\n\t        _classCallCheck(this, Arc);\n\t\n\t        return _possibleConstructorReturn(this, (Arc.__proto__ || Object.getPrototypeOf(Arc)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(Arc, [{\n\t        key: 'init',\n\t        value: function init(settings) {\n\t            // Update properties from user settings\n\t            Object.assign(this, settings || {});\n\t\n\t            // Get angle in radians\n\t            this.radians = mod(this.angle, 360) * DEG_TO_RAD;\n\t\n\t            // If the endpoints are identical, then this is equivalent\n\t            // to omitting the elliptical arc segment entirely.\n\t            if (this.p1.x === this.p2.x && this.p1.y === this.p2.y) {\n\t                return this.path;\n\t            }\n\t\n\t            this.rx = Math.abs(this.rx);\n\t            this.ry = Math.abs(this.ry);\n\t\n\t            // If rx = 0 or ry = 0 then this arc is treated as\n\t            // a straight line segment joining the endpoints.\n\t            if (this.rx === 0 || this.ry === 0) {\n\t                this.__addPoint(this.p1);\n\t                this.__addPoint(this.p2);\n\t                return this.path;\n\t            }\n\t\n\t            // Following \"Conversion from endpoint to center parameterization\"\n\t            // http://www.w3.org/TR/SVG/implnote.html#ArcConversionEndpointToCenter\n\t\n\t            // Step #1: Compute transformedPoint\n\t            var dx = (this.p1.x - this.p2.x) / 2;\n\t            var dy = (this.p1.y - this.p2.y) / 2;\n\t\n\t            var transformedPoint = {\n\t                x: Math.cos(this.radians) * dx + Math.sin(this.radians) * dy,\n\t                y: -Math.sin(this.radians) * dx + Math.cos(this.radians) * dy\n\t            };\n\t\n\t            // Ensure radii are large enough\n\t            var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(this.rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(this.ry, 2);\n\t\n\t            if (radiiCheck > 1) {\n\t                this.rx = Math.sqrt(radiiCheck) * this.rx;\n\t                this.ry = Math.sqrt(radiiCheck) * this.ry;\n\t            }\n\t\n\t            // Step #2: Compute transformedCenter\n\t            var cSquareNumerator = Math.pow(this.rx, 2) * Math.pow(this.ry, 2) - Math.pow(this.rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(this.ry, 2) * Math.pow(transformedPoint.x, 2);\n\t            var cSquareRootDenom = Math.pow(this.rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(this.ry, 2) * Math.pow(transformedPoint.x, 2);\n\t            var cRadicand = cSquareNumerator / cSquareRootDenom;\n\t\n\t            // Make sure this never drops below zero because of precision\n\t            cRadicand = cRadicand < 0 ? 0 : cRadicand;\n\t            var cCoef = (this.large !== this.sweep ? 1 : -1) * Math.sqrt(cRadicand);\n\t            var transformedCenter = {\n\t                x: cCoef * (this.rx * transformedPoint.y / this.ry),\n\t                y: cCoef * (-(this.ry * transformedPoint.x) / this.rx)\n\t            };\n\t\n\t            // Step #3: Compute center\n\t            this.center = {\n\t                x: Math.cos(this.radians) * transformedCenter.x - Math.sin(this.radians) * transformedCenter.y + (this.p1.x + this.p2.x) / 2,\n\t                y: Math.sin(this.radians) * transformedCenter.x + Math.cos(this.radians) * transformedCenter.y + (this.p1.y + this.p2.y) / 2\n\t            };\n\t\n\t            // Step #4: Compute start/sweep angles\n\t            // Start angle of the elliptical arc prior to the stretch and rotate operations.\n\t            // Difference between the start and end angles\n\t            var startVector = {\n\t                x: (transformedPoint.x - transformedCenter.x) / this.rx,\n\t                y: (transformedPoint.y - transformedCenter.y) / this.ry\n\t            };\n\t\n\t            var endVector = {\n\t                x: (-transformedPoint.x - transformedCenter.x) / this.rx,\n\t                y: (-transformedPoint.y - transformedCenter.y) / this.ry\n\t            };\n\t\n\t            this.startAngle = angle({ x: 1, y: 0 }, startVector);\n\t            this.sweepAngle = angle(startVector, endVector);\n\t\n\t            if (!this.sweep && this.sweepAngle > 0) {\n\t                this.sweepAngle -= MATH_PI_2;\n\t            } else if (this.sweep && this.sweepAngle < 0) {\n\t                this.sweepAngle += MATH_PI_2;\n\t            }\n\t\n\t            // We use % instead of `mod(..)` because we want it to be -360deg to 360deg(but actually in radians)\n\t            this.sweepAngle %= MATH_PI_2;\n\t        }\n\t    }, {\n\t        key: 'trace',\n\t        value: function trace(settings) {\n\t            this.init(settings);\n\t            return _get(Arc.prototype.__proto__ || Object.getPrototypeOf(Arc.prototype), 'trace', this).call(this);\n\t        }\n\t    }, {\n\t        key: 'getPointAtT',\n\t        value: function getPointAtT(t) {\n\t            var angle = this.startAngle + this.sweepAngle * t;\n\t\n\t            var x = this.rx * Math.cos(angle);\n\t            var y = this.ry * Math.sin(angle);\n\t\n\t            return new _lw.Point(Math.cos(this.radians) * x - Math.sin(this.radians) * y + this.center.x, Math.sin(this.radians) * x + Math.cos(this.radians) * y + this.center.y);\n\t        }\n\t    }, {\n\t        key: '_postTrace',\n\t        value: function _postTrace() {\n\t            // Add last point in the path\n\t            this._addPoint(this.p2);\n\t        }\n\t    }]);\n\t\n\t    return Arc;\n\t}(TraceBase);\n\t\n\tvar CubicBezier = function (_TraceBase2) {\n\t    _inherits(CubicBezier, _TraceBase2);\n\t\n\t    function CubicBezier() {\n\t        _classCallCheck(this, CubicBezier);\n\t\n\t        return _possibleConstructorReturn(this, (CubicBezier.__proto__ || Object.getPrototypeOf(CubicBezier)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(CubicBezier, [{\n\t        key: '_B1',\n\t        value: function _B1(t) {\n\t            return t * t * t;\n\t        }\n\t    }, {\n\t        key: '_B2',\n\t        value: function _B2(t) {\n\t            return 3 * t * t * (1 - t);\n\t        }\n\t    }, {\n\t        key: '_B3',\n\t        value: function _B3(t) {\n\t            return 3 * t * (1 - t) * (1 - t);\n\t        }\n\t    }, {\n\t        key: '_B4',\n\t        value: function _B4(t) {\n\t            return (1 - t) * (1 - t) * (1 - t);\n\t        }\n\t    }, {\n\t        key: '_C1',\n\t        value: function _C1(p1, p2, p3, p4, t) {\n\t            return p1 * this._B1(t) + p2 * this._B2(t) + p3 * this._B3(t) + p4 * this._B4(t);\n\t        }\n\t    }, {\n\t        key: 'getPointAtT',\n\t        value: function getPointAtT(t) {\n\t            return new _lw.Point(this._C1(this.p1.x, this.p2.x, this.p3.x, this.p4.x, t), this._C1(this.p1.y, this.p2.y, this.p3.y, this.p4.y, t));\n\t        }\n\t    }, {\n\t        key: '_addPoint',\n\t        value: function _addPoint(point) {\n\t            this.path.unshift(point.x, point.y);\n\t        }\n\t    }]);\n\t\n\t    return CubicBezier;\n\t}(TraceBase);\n\t\n\tvar QuadricBezier = function (_TraceBase3) {\n\t    _inherits(QuadricBezier, _TraceBase3);\n\t\n\t    function QuadricBezier() {\n\t        _classCallCheck(this, QuadricBezier);\n\t\n\t        return _possibleConstructorReturn(this, (QuadricBezier.__proto__ || Object.getPrototypeOf(QuadricBezier)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(QuadricBezier, [{\n\t        key: '_B1',\n\t        value: function _B1(t) {\n\t            return t * t;\n\t        }\n\t    }, {\n\t        key: '_B2',\n\t        value: function _B2(t) {\n\t            return 2 * t * (1 - t);\n\t        }\n\t    }, {\n\t        key: '_B3',\n\t        value: function _B3(t) {\n\t            return (1 - t) * (1 - t);\n\t        }\n\t    }, {\n\t        key: '_C1',\n\t        value: function _C1(p1, p2, p3, t) {\n\t            return p1 * this._B1(t) + p2 * this._B2(t) + p3 * this._B3(t);\n\t        }\n\t    }, {\n\t        key: 'getPointAtT',\n\t        value: function getPointAtT(t) {\n\t            return new _lw.Point(this._C1(this.p1.x, this.p2.x, this.p3.x, t), this._C1(this.p1.y, this.p2.y, this.p3.y, t));\n\t        }\n\t    }, {\n\t        key: '_addPoint',\n\t        value: function _addPoint(point) {\n\t            this.path.unshift(point.x, point.y);\n\t        }\n\t    }]);\n\t\n\t    return QuadricBezier;\n\t}(TraceBase);\n\t\n\t// Exports\n\t\n\t\n\texports.Arc = Arc;\n\texports.CubicBezier = CubicBezier;\n\texports.QuadricBezier = QuadricBezier;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t!function(t,n){ true?module.exports=n():\"function\"==typeof define&&define.amd?define(\"SVGPath\",[],n):\"object\"==typeof exports?exports.SVGPath=n():t.SVGPath=n()}(this,function(){return function(t){function n(i){if(e[i])return e[i].exports;var o=e[i]={exports:{},id:i,loaded:!1};return t[i].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}var e={};return n.m=t,n.c=e,n.p=\"\",n(0)}([function(t,n,e){t.exports=e(1)},function(t,n){\"use strict\";function e(t,n){if(!(t instanceof n))throw new TypeError(\"Cannot call a class as a function\")}Object.defineProperty(n,\"__esModule\",{value:!0});var i=function(){function t(t,n){for(var e=0;e<n.length;e++){var i=n[e];i.enumerable=i.enumerable||!1,i.configurable=!0,\"value\"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(n,e,i){return e&&t(n.prototype,e),i&&t(n,i),n}}(),o=function(){function t(n,i){if(e(this,t),this.x=parseFloat(n),this.y=parseFloat(i),isNaN(this.x)||isNaN(this.y))throw console.error(\"new Point(\",n,i,\")\"),new Error(\"Invalid input: x and y params must be float.\")}return i(t,[{key:\"isEqual\",value:function(t){return this.x===t.x&&this.y===t.y}}]),t}(),r=function(){function t(){e(this,t),this.points=[],this.length=0}return i(t,[{key:\"getPoints\",value:function(){return this.points}},{key:\"getFlattenPoints\",value:function(){var t=[];return this.points.forEach(function(n){return t.push(n.x,n.y)}),t}},{key:\"getClipperPoints\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,n=[];return this.points.forEach(function(e){return n.push({X:parseInt(e.x*t),Y:parseInt(e.y*t)})}),n}},{key:\"fromClipperPoints\",value:function(t){var n=this,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return this.points=[],t.forEach(function(t){return n.addPoint(parseFloat(t.X*e),parseFloat(t.Y*e))}),this}},{key:\"getPoint\",value:function(t){return this.points[t<0?this.length+t:t]||null}},{key:\"addPoint\",value:function(t,n){this.points.push(new o(t,n)),this.length=this.points.length}},{key:\"addPoints\",value:function(t){for(var n=0,e=t.length;n<e;n+=2)this.addPoint(t[n],t[n+1])}},{key:\"isClosed\",value:function(){var t=this.getPoint(0);return t&&t.isEqual(this.getPoint(-1))}},{key:\"close\",value:function(){if(!this.isClosed()&&this.length>2){var t=this.getPoint(0);return this.addPoint(t.x,t.y),!0}return!1}},{key:\"transform\",value:function(t){this.points=this.points.map(function(n){return new o(t[0]*n.x+t[2]*n.y+t[4],t[1]*n.x+t[3]*n.y+t[5])})}}]),t}();n.Path=r,n.Point=o,n.default=r}])});\n\t//# sourceMappingURL=lw.svg-path.js.map\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// lw.svg-curves.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap aded64610fa5676dd311","// Base code from : https://github.com/MadLittleMods/svg-curve-lib/blob/master/src/js/svg-curve-lib.js\nimport { Point } from 'lw.svg-path'\n\nconst MATH_PI_2  = Math.PI * 2\nconst DEG_TO_RAD = Math.PI / 180\n\nfunction mod(x, m) {\n    return (x % m + m) % m\n}\n\nfunction clamp(val, min, max) {\n    return Math.min(Math.max(val, min), max)\n}\n\nfunction distance(p0, p1) {\n    return Math.sqrt(Math.pow(p1.x - p0.x, 2) + Math.pow(p1.y - p0.y, 2))\n}\n\nfunction angle(v0, v1) {\n    let p = v0.x * v1.x + v0.y * v1.y\n    let n = Math.sqrt((Math.pow(v0.x, 2) + Math.pow(v0.y, 2)) * (Math.pow(v1.x, 2) + Math.pow(v1.y, 2)))\n    return (v0.x * v1.y - v0.y * v1.x < 0 ? -1 : 1) * Math.acos(p / n)\n}\n\n// Abstract class\nclass TraceBase {\n    constructor(settings) {\n        // Set defaults properties\n        this.path          = []   // Points collection [x,y, x,y, ...]\n        this.linear        = true // Linear trace mode\n        this.step          = 0.01 // Step resolution if linear mode = false\n        this.resolution    = 500  // Number of segments we use to approximate arc length\n        this.segmentLength = 0.1  // Segment length\n\n        // Update properties from user settings\n        Object.assign(this, settings || {})\n\n        // Arc length properties\n        this.arcLength    = null\n        this.arcLengthMap = null\n    }\n\n    _clearPath() {\n        this.path = []\n    }\n\n    getPath() {\n        return this.path\n    }\n\n    getPointAtT(t) {\n        return new Point(0, 0)\n    }\n\n    _addPoint(point) {\n        this.path.push(point.x, point.y)\n    }\n\n    _postTrace() {\n        // Do additional tasks\n    }\n\n    _approximateLength() {\n        let arcLength    = 0\n        let arcLengthMap = []\n        let prevPoint    = this.getPointAtT(0)\n\n        let i, t, nextPoint\n\n        for(i = 0; i < this.resolution; i++) {\n            t          = clamp(i * (1 / this.resolution), 0, 1)\n            nextPoint  = this.getPointAtT(t)\n            arcLength += distance(prevPoint, nextPoint)\n\n            arcLengthMap.push({ t: t, arcLength: arcLength })\n\n            prevPoint = nextPoint\n        }\n\n        // Last stretch to the endpoint\n        nextPoint  = this.getPointAtT(1)\n        arcLength += distance(prevPoint, nextPoint)\n\n        arcLengthMap.push({ t: 1, arcLength: arcLength })\n        Object.assign(this, { arcLength, arcLengthMap })\n    }\n\n    getPointAtU(u) {\n        u = clamp(u, 0, 1)\n\n        let targetDistanceFromStartingPoint = u * this.arcLength\n\n        let resultantT    = 0\n        let prevArcLength = 0\n        let prevT         = 0\n\n        this.arcLengthMap.every(entry => {\n            let t         = entry.t\n            let arcLength = entry.arcLength\n\n            // Once we go a past our target\n            // Lets interpolate from a previous to current\n            if (arcLength >= targetDistanceFromStartingPoint) {\n                let endDiff      = arcLength - targetDistanceFromStartingPoint\n                let startDiff    = targetDistanceFromStartingPoint - prevArcLength\n                let linearFactor = (startDiff / (endDiff + startDiff)) || 0\n\n                resultantT = prevT + (t - prevT) * linearFactor\n\n                // Break\n                return false\n            }\n\n            prevArcLength = arcLength\n            prevT = t\n\n            return true\n        })\n\n        return this.getPointAtT(resultantT)\n    }\n\n    trace(settings) {\n        // Update properties from user settings\n        Object.assign(this, settings || {})\n\n        // Default getPoint settings\n        let getPoint = 'getPointAtT'\n        let step     = this.step\n\n        // Linear mode ?\n        if (this.linear) {\n            this._approximateLength()\n\n            let segments = Math.round(this.arcLength / this.segmentLength)\n\n            getPoint = 'getPointAtU'\n            step     = 1 / segments\n        }\n\n        // Clear points list\n        this._clearPath()\n\n        // Trace the path\n        for (let t = 0; t <= 1; t += step) {\n            this._addPoint(this[getPoint](t))\n        }\n\n        // Do additional tasks\n        this._postTrace()\n\n        // Return the path\n        return this.getPath()\n    }\n}\n\n// Rewrite from https://github.com/MadLittleMods/svg-curve-lib/blob/master/src/js/svg-curve-lib.js#L84\nclass Arc extends TraceBase {\n    init(settings) {\n        // Update properties from user settings\n        Object.assign(this, settings || {})\n\n        // Get angle in radians\n        this.radians = mod(this.angle, 360) * DEG_TO_RAD\n\n        // If the endpoints are identical, then this is equivalent\n        // to omitting the elliptical arc segment entirely.\n        if(this.p1.x === this.p2.x && this.p1.y === this.p2.y) {\n            return this.path\n        }\n\n        this.rx = Math.abs(this.rx)\n        this.ry = Math.abs(this.ry)\n\n        // If rx = 0 or ry = 0 then this arc is treated as\n        // a straight line segment joining the endpoints.\n        if (this.rx === 0 || this.ry === 0) {\n            this.__addPoint(this.p1)\n            this.__addPoint(this.p2)\n            return this.path\n        }\n\n        // Following \"Conversion from endpoint to center parameterization\"\n        // http://www.w3.org/TR/SVG/implnote.html#ArcConversionEndpointToCenter\n\n        // Step #1: Compute transformedPoint\n        let dx = (this.p1.x - this.p2.x) / 2\n        let dy = (this.p1.y - this.p2.y) / 2\n\n        let transformedPoint = {\n            x:  Math.cos(this.radians) * dx + Math.sin(this.radians) * dy,\n            y: -Math.sin(this.radians) * dx + Math.cos(this.radians) * dy\n        }\n\n        // Ensure radii are large enough\n        let radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(this.rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(this.ry, 2)\n\n        if (radiiCheck > 1) {\n            this.rx = Math.sqrt(radiiCheck) * this.rx\n            this.ry = Math.sqrt(radiiCheck) * this.ry\n        }\n\n        // Step #2: Compute transformedCenter\n        let cSquareNumerator = Math.pow(this.rx, 2) * Math.pow(this.ry, 2) - Math.pow(this.rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(this.ry, 2) * Math.pow(transformedPoint.x, 2)\n        let cSquareRootDenom = Math.pow(this.rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(this.ry, 2) * Math.pow(transformedPoint.x, 2)\n        let cRadicand        = cSquareNumerator / cSquareRootDenom\n\n        // Make sure this never drops below zero because of precision\n        cRadicand = cRadicand < 0 ? 0 : cRadicand\n        let cCoef = (this.large !== this.sweep ? 1 : -1) * Math.sqrt(cRadicand)\n        let transformedCenter = {\n            x: cCoef * ( (this.rx * transformedPoint.y) / this.ry),\n            y: cCoef * (-(this.ry * transformedPoint.x) / this.rx)\n        }\n\n        // Step #3: Compute center\n        this.center = {\n            x: Math.cos(this.radians) * transformedCenter.x - Math.sin(this.radians) * transformedCenter.y + ((this.p1.x + this.p2.x) / 2),\n            y: Math.sin(this.radians) * transformedCenter.x + Math.cos(this.radians) * transformedCenter.y + ((this.p1.y + this.p2.y) / 2)\n        }\n\n        // Step #4: Compute start/sweep angles\n        // Start angle of the elliptical arc prior to the stretch and rotate operations.\n        // Difference between the start and end angles\n        let startVector = {\n            x: (transformedPoint.x - transformedCenter.x) / this.rx,\n            y: (transformedPoint.y - transformedCenter.y) / this.ry\n        }\n\n        let endVector = {\n            x: (-transformedPoint.x - transformedCenter.x) / this.rx,\n            y: (-transformedPoint.y - transformedCenter.y) / this.ry\n        }\n\n        this.startAngle = angle({ x: 1, y: 0 }, startVector)\n        this.sweepAngle = angle(startVector, endVector)\n\n        if (! this.sweep && this.sweepAngle > 0) {\n            this.sweepAngle -= MATH_PI_2\n        }\n\n        else if (this.sweep && this.sweepAngle < 0) {\n            this.sweepAngle += MATH_PI_2\n        }\n\n        // We use % instead of `mod(..)` because we want it to be -360deg to 360deg(but actually in radians)\n        this.sweepAngle %= MATH_PI_2\n    }\n\n    trace(settings) {\n        this.init(settings)\n        return super.trace()\n    }\n\n    getPointAtT(t) {\n        let angle = this.startAngle + (this.sweepAngle * t)\n\n        let x = this.rx * Math.cos(angle)\n        let y = this.ry * Math.sin(angle)\n\n        return new Point(\n            Math.cos(this.radians) * x - Math.sin(this.radians) * y + this.center.x,\n            Math.sin(this.radians) * x + Math.cos(this.radians) * y + this.center.y\n        )\n    }\n\n    _postTrace() {\n        // Add last point in the path\n        this._addPoint(this.p2)\n    }\n}\n\nclass CubicBezier extends TraceBase {\n    _B1(t) { return t*t*t }\n    _B2(t) { return 3*t*t*(1-t) }\n    _B3(t) { return 3*t*(1-t)*(1-t) }\n    _B4(t) { return (1-t)*(1-t)*(1-t) }\n\n    _C1(p1, p2, p3, p4, t) {\n        return p1*this._B1(t) + p2*this._B2(t) + p3*this._B3(t) + p4*this._B4(t)\n    }\n\n    getPointAtT(t) {\n        return new Point(\n            this._C1(this.p1.x, this.p2.x, this.p3.x, this.p4.x, t),\n            this._C1(this.p1.y, this.p2.y, this.p3.y, this.p4.y, t)\n        )\n    }\n\n    _addPoint(point) {\n        this.path.unshift(point.x, point.y)\n    }\n}\n\nclass QuadricBezier extends TraceBase {\n    _B1(t) { return t*t }\n    _B2(t) { return 2*t*(1-t) }\n    _B3(t) { return (1-t)*(1-t) }\n\n    _C1(p1, p2, p3, t) {\n        return p1*this._B1(t) + p2*this._B2(t) + p3*this._B3(t)\n    }\n\n    getPointAtT(t) {\n        return new Point(\n            this._C1(this.p1.x, this.p2.x, this.p3.x, t),\n            this._C1(this.p1.y, this.p2.y, this.p3.y, t)\n        )\n    }\n\n    _addPoint(point) {\n        this.path.unshift(point.x, point.y)\n    }\n}\n\n// Exports\nexport { Arc, CubicBezier, QuadricBezier }\n\n\n\n// WEBPACK FOOTER //\n// ./curves.js","!function(t,n){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=n():\"function\"==typeof define&&define.amd?define(\"SVGPath\",[],n):\"object\"==typeof exports?exports.SVGPath=n():t.SVGPath=n()}(this,function(){return function(t){function n(i){if(e[i])return e[i].exports;var o=e[i]={exports:{},id:i,loaded:!1};return t[i].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}var e={};return n.m=t,n.c=e,n.p=\"\",n(0)}([function(t,n,e){t.exports=e(1)},function(t,n){\"use strict\";function e(t,n){if(!(t instanceof n))throw new TypeError(\"Cannot call a class as a function\")}Object.defineProperty(n,\"__esModule\",{value:!0});var i=function(){function t(t,n){for(var e=0;e<n.length;e++){var i=n[e];i.enumerable=i.enumerable||!1,i.configurable=!0,\"value\"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(n,e,i){return e&&t(n.prototype,e),i&&t(n,i),n}}(),o=function(){function t(n,i){if(e(this,t),this.x=parseFloat(n),this.y=parseFloat(i),isNaN(this.x)||isNaN(this.y))throw console.error(\"new Point(\",n,i,\")\"),new Error(\"Invalid input: x and y params must be float.\")}return i(t,[{key:\"isEqual\",value:function(t){return this.x===t.x&&this.y===t.y}}]),t}(),r=function(){function t(){e(this,t),this.points=[],this.length=0}return i(t,[{key:\"getPoints\",value:function(){return this.points}},{key:\"getFlattenPoints\",value:function(){var t=[];return this.points.forEach(function(n){return t.push(n.x,n.y)}),t}},{key:\"getClipperPoints\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,n=[];return this.points.forEach(function(e){return n.push({X:parseInt(e.x*t),Y:parseInt(e.y*t)})}),n}},{key:\"fromClipperPoints\",value:function(t){var n=this,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return this.points=[],t.forEach(function(t){return n.addPoint(parseFloat(t.X*e),parseFloat(t.Y*e))}),this}},{key:\"getPoint\",value:function(t){return this.points[t<0?this.length+t:t]||null}},{key:\"addPoint\",value:function(t,n){this.points.push(new o(t,n)),this.length=this.points.length}},{key:\"addPoints\",value:function(t){for(var n=0,e=t.length;n<e;n+=2)this.addPoint(t[n],t[n+1])}},{key:\"isClosed\",value:function(){var t=this.getPoint(0);return t&&t.isEqual(this.getPoint(-1))}},{key:\"close\",value:function(){if(!this.isClosed()&&this.length>2){var t=this.getPoint(0);return this.addPoint(t.x,t.y),!0}return!1}},{key:\"transform\",value:function(t){this.points=this.points.map(function(n){return new o(t[0]*n.x+t[2]*n.y+t[4],t[1]*n.x+t[3]*n.y+t[5])})}}]),t}();n.Path=r,n.Point=o,n.default=r}])});\n//# sourceMappingURL=lw.svg-path.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/lw.svg-path/dist/lw.svg-path.js\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}